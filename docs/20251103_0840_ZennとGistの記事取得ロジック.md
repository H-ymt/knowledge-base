# ZennとGistの記事取得ロジック

このドキュメントでは、このリポジトリでZennとGistの記事を取得しているロジックについて詳細に説明します。

## 記事取得ロジックの全体像

このリポジトリでは、`scripts/fetch-knowledge.ts` がメインスクリプトとして機能しています。GitHub Gist APIとZennのRSSフィードから記事を取得し、統一されたデータ形式（`KnowledgeEntry`）に正規化して、`src/data/entries.json` に保存します。

## 1. メインスクリプトの処理フロー

### 1.1 エントリーポイント

メインスクリプト（`scripts/fetch-knowledge.ts`）は以下の処理を実行します：

1. **環境変数の読み込み**: `GITHUB_USERNAME`, `GITHUB_TOKEN`, `ZENN_USER` などの環境変数を取得
2. **コマンドライン引数の解析**: `--source`, `--force`, `--limit`, `--since` などのオプションを処理
3. **並列データ取得**: GistとZennのデータを `Promise.all` で並列に取得
4. **エラーハンドリング**: いずれかのソースでエラーが発生しても、他のソースの処理は継続
5. **データの統合**: 両方のソースから取得したデータをマージ
6. **304 レスポンス処理**: 更新がない場合は既存の `entries.json` を保持
7. **後処理**: フィルタリング、重複解消、ソートを実行
8. **JSON出力**: 最終的なデータを `src/data/entries.json` に保存

### 1.2 主な処理ステップ

```typescript
// 1. 環境変数と引数の読み込み
const env = readEnv();
const args = parseArgs(process.argv.slice(2));

// 2. 並列データ取得
const tasks: Promise<KnowledgeEntry[]>[] = [];
// Gist取得タスク
if (env.GITHUB_USERNAME && (args.source === "all" || args.source === "gist")) {
  tasks.push(gist.fetchUserGists(...).then(normalizeGist));
}
// Zenn取得タスク
if (env.ZENN_USER && (args.source === "all" || args.source === "zenn")) {
  tasks.push(zenn.fetchFeed(...).then(normalizeZenn));
}

// 3. 結果の統合
const lists = await Promise.all(tasks);
let entries = lists.flat();

// 4. 304処理（更新なしの場合は既存データを保持）
if (entries.length === 0) {
  // 既存の entries.json を読み込む
}

// 5. フィルタリングとソート
if (args.since) entries = entries.filter(...);
entries = ensureUniqueSlugs(entries);
entries.sort(...);

// 6. 出力
await writeFile(out.entriesJson, JSON.stringify(entries, null, 2));
```

## 2. GitHub Gist 取得ロジック

### 2.1 クライアントの作成

Gistクライアントは `src/lib/clients/gist.ts` で定義されています。

```typescript
const gist = createGistClient({
  username: env.GITHUB_USERNAME,
  token: env.GITHUB_TOKEN,
});
```

### 2.2 取得処理の詳細

#### ETag による差分取得

- **目的**: 不要なAPIコールを削減し、レート制限を回避
- **仕組み**: 前回取得時のETagを `.cache/etag.json` に保存し、次回のリクエストで `If-None-Match` ヘッダーに含める
- **304 レスポンス**: サーバーが304を返す場合、データに変更がないと判断して処理をスキップ

```typescript
const etagKey = `gist:${username}`;
const prevEtag = options?.force ? undefined : await getETag(etagKey);
if (prevEtag) headers["If-None-Match"] = prevEtag;
```

#### ページネーション

- **APIエンドポイント**: `GET https://api.github.com/users/{username}/gists`
- **ページサイズ**: `per_page=100`（最大100件まで一度に取得可能）
- **次のページ**: `Link` ヘッダーから `rel="next"` のURLを解析して次ページを取得

```typescript
while (nextUrl) {
  const res = await fetchWithRetry(nextUrl, headers);
  const data = await res.json();
  collected.push(...data);

  const links = parseLinkHeader(res.headers.get("link"));
  if (links.next) {
    nextUrl = new URL(links.next);
    page += 1;
  } else {
    nextUrl = null; // 次のページがない場合は終了
  }
}
```

#### リトライ機構

- **最大試行回数**: 3回
- **指数バックオフ**: 失敗時は300ms, 600ms, 1200msと待機時間を増やす
- **レート制限対応**: `x-ratelimit-reset` ヘッダーを確認し、適切な待機時間を設定
- **429エラー**: レート制限に達した場合は、リセット時刻まで待機

```typescript
async function fetchWithRetry(input: URL, headers: Record<string, string>, maxAttempts = 3) {
  let attempt = 0;
  while (true) {
    attempt++;
    const res = await fetch(input, { headers });
    if (res.ok || res.status === 304) return res;
    if (attempt >= maxAttempts || (res.status < 500 && res.status !== 429)) return res;

    // レート制限の場合はリセット時刻まで待機
    const reset = res.headers.get("x-ratelimit-reset");
    const waitMs = res.status === 429 && reset ? Math.max(0, (parseInt(reset, 10) - now) * 1000) : 300 * Math.pow(2, attempt - 1);
    await new Promise((r) => setTimeout(r, waitMs));
  }
}
```

#### 認証

- **オプション**: GitHub Personal Access Tokenを `GITHUB_TOKEN` 環境変数で指定可能
- **効果**: 認証ありの場合はレート制限が緩和される（60req/h → 5000req/h）

### 2.3 取得されるデータ構造

GitHub Gist APIから取得されるデータは以下の構造です：

```typescript
interface GistApiItem {
  readonly id: string;
  readonly html_url: string;
  readonly description: string | null;
  readonly public: boolean;
  readonly created_at: string; // ISO8601
  readonly updated_at: string; // ISO8601
  readonly files: Record<string, GistApiFileInfo>;
  readonly owner?: { readonly login: string } | null;
}
```

## 3. Zenn 取得ロジック

### 3.1 クライアントの作成

Zennクライアントは `src/lib/clients/zenn.ts` で定義されています。

```typescript
const zenn = createZennClient({
  user: env.ZENN_USER,
  includeScraps: true, // スクラップも取得する
});
```

### 3.2 取得処理の詳細

#### RSSフィードの取得

- **記事フィード**: `https://zenn.dev/{user}/feed`
- **スクラップフィード**: `https://zenn.dev/{user}/scraps/feed`
- **取得順序**: まず記事を取得し、その後スクラップを取得（`includeScraps=true` の場合）

```typescript
const articles = await fetchOne("articles");
const scraps = includeScraps ? await fetchOne("scraps") : { items: [] };
return { items: [...articles.items, ...scraps.items] };
```

#### ETag による差分取得

- **記事とスクラップを別管理**: `zenn:{user}:articles` と `zenn:{user}:scraps` として別々にETagを保存
- **304 レスポンス**: 更新がない場合は空のアイテム配列を返す

```typescript
const etagKey = `zenn:${user}:${kind}`;
const prevEtag = options?.force ? undefined : await getETag(etagKey);
if (prevEtag) headers["If-None-Match"] = prevEtag;
```

#### スクラップ未利用ユーザーへの対応

- **404エラー**: スクラップを利用していないユーザーは404を返すことがある
- **エラー無視**: スクラップの404エラーは空配列として処理し、記事の取得は継続

```typescript
if (!res.ok) {
  if (res.status === 404 && kind === "scraps") {
    return { title: `zenn:${user}:${kind}`, link: url.toString(), items: [] };
  }
  throw new Error(`ZennClient: HTTP ${res.status} (${kind})`);
}
```

#### RSS/Atom フィードのパース

ZennはRSS 2.0形式のフィードを提供しますが、Atom形式にも対応できるように実装されています。

- **正規表現によるパース**: DOMパーサーを使わず、正規表現でXMLタグを抽出
- **RSS/Atom両対応**: `<item>` (RSS) と `<entry>` (Atom) の両方をサポート
- **HTMLエンティティのデコード**: CDATAセクションとHTMLエンティティ（`&lt;`, `&gt;` など）を適切にデコード

```typescript
function parseZennXml(xml: string, link: string): ZennFeed {
  const rssItems = parseTag(xml, "item");
  const atomEntries = rssItems.length === 0 ? parseTag(xml, "entry") : [];
  const blocks = rssItems.length > 0 ? rssItems : atomEntries;

  const items = blocks.map((block) => {
    const title = unescapeHtml(parseTag(block, "title")[0] ?? "");
    const link = parseTag(block, "link")[0] || parseLinkHref(block);
    // ...
  });
}
```

### 3.3 取得されるデータ構造

Zenn RSSフィードから取得されるデータは以下の構造です：

```typescript
interface ZennFeedItem {
  readonly id?: string;
  readonly title: string;
  readonly link: string;
  readonly description?: string;
  readonly pubDate?: string; // RFC822 or ISO-like
}

interface ZennFeed {
  readonly title?: string;
  readonly link?: string;
  readonly items: ReadonlyArray<ZennFeedItem>;
}
```

## 4. データ正規化

### 4.1 Gistの正規化

`normalizeGist` 関数（`src/lib/adapters/normalize.ts`）が、GitHub Gist APIのレスポンスを `KnowledgeEntry` 形式に変換します。

#### 処理内容

1. **タイトルの決定**:
   - `description` があればそれを使用
   - なければ最初のファイル名を使用
   - それもなければ Gist ID を使用

2. **スラッグ生成**:
   - タイトルとGist IDからURLセーフなスラッグを生成
   - `toSlugWithHint` 関数を使用（重複回避のためIDを含める）

3. **タグの構築**:
   - 必須タグ: `gist`
   - 追加タグ: ファイルに含まれる言語（JavaScript、Python、TypeScriptなど）

4. **日付の正規化**:
   - `publishedAt`: `created_at` をISO8601形式に変換
   - `updatedAt`: `updated_at` をISO8601形式に変換（存在する場合）

```typescript
export function normalizeGist(gists: ReadonlyArray<GistApiItem>): KnowledgeEntry[] {
  return gists.map((g) => {
    const title = g.description?.trim() || (Object.keys(g.files)[0] ?? g.id);
    const slug = toSlugWithHint(title, g.id);
    const languages = Object.values(g.files)
      .map((f) => f.language || "")
      .filter(Boolean) as string[];
    const tags = buildTags(["gist", ...languages]);
    const publishedAt = toISODateString(g.created_at) ?? toISODateString(g.updated_at)!;

    return {
      id: g.id,
      source: "gist",
      slug,
      title,
      summary: g.description ?? title,
      url: g.html_url,
      tags,
      publishedAt,
      updatedAt: toISODateString(g.updated_at) ?? undefined,
      author: g.owner?.login ?? undefined,
    };
  });
}
```

### 4.2 Zennの正規化

`normalizeZenn` 関数が、Zenn RSSフィードを `KnowledgeEntry` 形式に変換します。

#### 処理内容

1. **タイトルの決定**:
   - RSSの `title` を使用
   - なければ `link`（URL）を使用

2. **スラッグ生成**:
   - タイトルとID（またはURL）からURLセーフなスラッグを生成

3. **タグの構築**:
   - 必須タグ: `zenn` のみ
   - 記事種別（記事/スクラップ）の区別は行わない

4. **日付の正規化**:
   - `publishedAt`: `pubDate` をISO8601形式に変換
   - `pubDate` がない場合は現在時刻を使用

```typescript
export function normalizeZenn(feed: ZennFeed): KnowledgeEntry[] {
  return feed.items.map((it) => {
    const title = it.title?.trim() ?? it.link;
    const id = it.id ?? it.link;
    const slug = toSlugWithHint(title, id);
    const publishedAt = it.pubDate ? toISODateString(it.pubDate) : null;
    const tags = buildTags(["zenn"]);

    return {
      id,
      source: "zenn",
      slug,
      title,
      summary: it.description ?? title,
      url: it.link,
      tags,
      publishedAt: publishedAt ?? toISODateString(Date.now())!,
    };
  });
}
```

### 4.3 統一データ形式（KnowledgeEntry）

正規化後のデータは以下の形式に統一されます：

```typescript
interface KnowledgeEntry {
  readonly id: string;
  readonly source: "gist" | "zenn";
  readonly slug: Slug; // URLセーフなスラッグ（ブランド型）
  readonly title: string;
  readonly summary: string;
  readonly url: string;
  readonly tags: ReadonlyArray<Tag>;
  readonly publishedAt: ISODateString; // ISO8601形式（ブランド型）
  readonly updatedAt?: ISODateString; // ISO8601形式（ブランド型）
  readonly contentHtml?: string;
  readonly author?: string;
  readonly image?: string;
}
```

## 5. キャッシュ管理（ETag）

### 5.1 キャッシュの保存先

- **ファイルパス**: `.cache/etag.json`
- **フォーマット**: JSONオブジェクト（キー: ETagのキー、値: ETagの値）

### 5.2 ETagキーの命名規則

- **Gist**: `gist:{username}`
- **Zenn記事**: `zenn:{user}:articles`
- **Zennスクラップ**: `zenn:{user}:scraps`

### 5.3 キャッシュの操作

```typescript
// ETagの取得
const prevEtag = await getETag(`gist:${username}`);

// ETagの保存
const etag = res.headers.get("etag");
if (etag) await setETag(`gist:${username}`, etag);
```

### 5.4 キャッシュの仕組み

1. **初回取得**: ETagが存在しないため、通常通りAPIリクエストを送信
2. **レスポンス取得**: サーバーから返されたETagを `.cache/etag.json` に保存
3. **次回取得**: 保存されたETagを `If-None-Match` ヘッダーに含めてリクエスト
4. **304 レスポンス**: サーバーが304を返す場合、データに変更がないため処理をスキップ
5. **更新あり**: 200レスポンスの場合は新しいデータを取得し、ETagを更新

この仕組みにより、**不要なAPIコールを削減**し、レート制限を回避し、処理時間を短縮できます。

## 6. 後処理

### 6.1 重複スラッグの解消

複数のエントリーが同じスラッグを持つ場合、後続のエントリーに連番を付与します。

```typescript
function ensureUniqueSlugs(entries: KnowledgeEntry[]): KnowledgeEntry[] {
  const counter = new Map<string, number>();
  return entries.map((e) => {
    const s = e.slug;
    const n = counter.get(s) ?? 0;
    counter.set(s, n + 1);
    if (n === 0) return e;
    const newSlug = (s + "-" + n) as typeof e.slug;
    return { ...e, slug: newSlug };
  });
}
```

### 6.2 ソート

エントリーは以下の順序でソートされます：

1. **第一優先**: `publishedAt` の降順（新しい順）
2. **第二優先**: `id` の辞書順（アルファベット順）

```typescript
entries.sort((a, b) => (a.publishedAt > b.publishedAt ? -1 : a.publishedAt < b.publishedAt ? 1 : a.id.localeCompare(b.id)));
```

### 6.3 フィルタリング（オプション）

`--since` オプションを指定すると、指定した日付以降のエントリーのみを取得します。

```typescript
if (args.since) {
  const sinceIso = toSinceIso(args.since);
  if (sinceIso) entries = entries.filter((e) => e.publishedAt >= sinceIso);
}
```

## 7. エラーハンドリング

### 7.1 個別ソースのエラー

GistまたはZennのいずれかでエラーが発生しても、他のソースの処理は継続されます。

```typescript
tasks.push(
  timeIt("gist", () => gist.fetchUserGists(...))
    .then((items) => normalizeGist(items))
    .catch((e) => {
      console.warn("[fetch-knowledge] gist skipped: %s", String(e));
      return [] as KnowledgeEntry[];
    })
);
```

### 7.2 304 レスポンスの処理

すべてのソースが304（更新なし）を返した場合、既存の `entries.json` を保持します。

```typescript
if (entries.length === 0) {
  try {
    const prevRaw = await readFile(out.entriesJson, "utf-8");
    const prev: unknown = JSON.parse(prevRaw);
    if (Array.isArray(prev) && prev.length > 0) {
      entries = prev as KnowledgeEntry[];
    }
  } catch {
    // 既存が無ければそのまま空で進む
  }
}
```

## 8. 型安全性

### 8.1 ブランド型の使用

スラッグと日付にはブランド型を使用し、型安全性を確保しています。

```typescript
export type Slug = string & { readonly __brand: "Slug" };
export type ISODateString = string & { readonly __brand: "ISODateString" };
```

### 8.2 型定義の集約

すべての型定義は `src/lib/types/index.ts` に集約され、一貫性が保たれています。

## まとめ

この記事取得システムの主な特徴：

1. **効率的な取得**: ETagによる差分取得でAPIコールを削減
2. **並列処理**: GistとZennを同時に取得して高速化
3. **統一データ形式**: 異なるソースのデータを `KnowledgeEntry` 形式に統一
4. **堅牢性**: リトライ機構とエラーハンドリングで信頼性を確保
5. **型安全性**: TypeScriptの型システムを活用してバグを防止

取得したデータは `src/data/entries.json` に保存され、Astroのビルド時に使用されます。
